---
title: Rasterize Lines in R
author: Michael Branion-Calles
date: '2020-10-21'
slug: []
categories:
  - R
  - sf
tags: []
subtitle: ''
summary: ''
authors: []
lastmod: '2020-10-21T12:39:56-07:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---

```{r setup, include=FALSE}
source("D:/GitHub/website-mbc/content/post/rasterize-lines/set-up.R")#load script with required packages

#Load Vector Data

vancouver_boundary <- st_read("D:/GitHub/website-mbc/content/post/rasterize-lines/input_data",
                 layer = "VanCT") %>% # census tract polygon
  mutate(area = st_area(.))%>%
  summarise(area = sum(area))  
  
seperated_bl <- st_read("D:/GitHub/website-mbc/content/post/rasterize-lines/input_data",
                   layer = "sep_bls")#separated bike lane polylines


```

# Rasterize line vector data

As a part of a University level GIS course I taught I needed to generate some raster data for a lab exercise on map algebra. I wrote a script to "rasterize" some vector data I already had on hand. This type of surface is common for the development of land use regression models, which require all input data to be continuous surfaces. For example, when developing a predictive surface for No2 concentrations, arterial road density within a given buffer length is likely an important predictor. Raster surfaces are created where every grid cell represents the line density of arterial roads within a given buffer size for the centroid of that grid cell. Here I develop a function to automate the process of creating such a surface in R using the sf package. 

The function "rasterize_lines" has 4 inputs:

1. inputStudyArea: A polygon representing the extent of the study area
2. inputLines: Polylines to be rasterized
3. cellSize: Spatial resolution of the output raster
4. buffWidth: Buffer length from which to calculate line densities from each raster cell centroid. 
5. mask: If TRUE then the output raster is clipped by the study area boundary. If FALSE then the output raster extent is equal to bounding box of study area boundary


The function "rasterize_lines" takes the following steps to rasterize the polylines: 

1. Create empty raster surface of specified grid cell size and study area extent
2. Generate buffers of specified length from the centroid of the empty raster surface
3. Split the polylines by the centroid buffers layer
4. Sum the length of polylines within each buffer in the centroid buffers layer
5. Assign the length within each buffer to the associated raster
6. Output raster where each grid cell has the value of the length of the polylines within the specified buffer length of the cell centroid

```{r}
#Function that takes an input study area polygon, input polyline data and creates a "rasterized" version of the data
#1. 

rasterize_lines <- function(inputStudyArea,inputLines,cellSize=100,buffWidth=300,mask=F){
  require(sf)
  require(raster)
  require(tidyverse)
  
  if(st_crs(inputStudyArea)$proj4string==st_crs(inputLines)$proj4string){ #check that both study area and polyline files are in the same coordinate system and projection
    
    
    print("Generating grid...")
    #Create template raster from Study Area extent (empty raster with the extent of the study area, and cell size as indicated)
    raster_template <- raster(extent(inputStudyArea), resolution = cellSize,
                              crs = st_crs(inputStudyArea)$proj4string)
    print("Buffering grid cell centroids....")

    rast_point <- rasterToPoints(raster_template, spatial = TRUE) %>% 
      st_as_sf() #create point layer from template raster based on the centroid 
    
    rast_point_buff <- st_buffer(rast_point,dist=buffWidth)#create buffers from raster cell centroids of specified width

    
    print("Finding intersections between grid cell centroid buffers and input lines...")
    
    #find intersection points between buffer boundaries and inputLines (e.g. isolate buffers that actually intersect with polyline data)
    rast_point_buff_ls <- st_cast(rast_point_buff,"LINESTRING")
    
    inputLines <- st_geometry(inputLines) %>%
      st_transform(crs = st_crs(rast_point_buff_ls)$proj4string)#reduce size of dataset and ensure proj4strings are the same
    
    int_points <- st_intersection(rast_point_buff_ls,inputLines) %>% #find intersection of road lines and centroid buffers
      st_cast("MULTIPOINT") %>%
      st_cast("POINT")
    
    print("Splitting input lines by intersections...")
    
    int_points_buff <- st_buffer(int_points,dist = 0.0000001) %>% st_combine() #buffer points to very small distance
    
    grid <- st_make_grid(rast_point_buff,what = "polygons",n = c(10,10))#split bounding box of polygon into grid
    grid <- grid[st_intersects(grid,int_points_buff,sparse = F)[,1]]#remove grid cells that do not intersect with the roads
    printPercent <- seq(from = 0, to = length(grid),by=(length(grid)/20))
    
    #iterate through each grid cell and intersect roads with grid cell, split the line geometry within that cell by the intersection buffers
    for (i in 1:length(grid)) {
      temp <- st_intersection(int_points_buff, grid[i])
      inputLines <- st_difference(inputLines, temp)
      
      if (i %in% round(printPercent)) {
        print(paste(round(i / length(grid) * 100, 0),
                    "% of lines split"))
      }
    }
    
    print("Calculating lengths of split polylines...")
    
    inputLines_ls <- inputLines %>%
      st_cast("MULTILINESTRING") %>%
      st_cast("LINESTRING")#convert to linestring to isolate non-contiguous lines
    
    inputLines_ls <-
      st_sf(data.frame(length_m = st_length(inputLines_ls)), geometry = inputLines_ls) #calculate each line segment length
    
    print("Spatially aggregating road lengths by each cell centroid buffer")
    
    #Join to line polygons, sum line segment length within each polygon
    rast_point_buff <-
      st_sf(data.frame(ID = seq(1, length(st_geometry(rast_point_buff))),
                       geometry = rast_point_buff)) #create sf object with the geometry of the point buffer
    
    rast_point_buff <- rast_point_buff %>%
      st_join(inputLines_ls) %>% #join lines split by buffer geometry and associated lengths to the buffer it falls within (e.g. points buffer is the target layer, input lines are join layer)
      group_by(ID) %>%
      summarize(line_length = sum(length_m),`.groups`="drop_last") %>%
      mutate(line_length = replace_na(line_length, 0)) %>% 
      st_set_agr(c(line_length = "identity", ID = "identity")) #specify attribute-geometry relationship to avoid warning since we already know line_length represents the value over the entire geometry
    
    rast_point_buff_cntrd <- st_centroid(rast_point_buff)
    
    output_rast = rasterize(rast_point_buff_cntrd,
                            raster_template,
                            field = "line_length",
                            fun = sum)
    
    if(mask==TRUE){
      
      output_rast <- mask(output_rast, as(inputStudyArea, "Spatial"))
      
      
    }
    
    
  }else{
    "Input study area must be in the same projection as input lines"
    
    
  }
  
    return(output_rast)
  
}

```


# Example

Here we have a map of the City of Vancouver's separated bike lanes as input data:

## Inputs


```{r,echo=FALSE}
ggplot(vancouver_boundary) +
  geom_sf() + 
  ggtitle("Input Study Area Polygon (City of Vancouver)") + 
  xlab("Longitude") + 
  ylab("Latitude") +
  theme_bw()

ggplot(seperated_bl) +
  geom_sf() + 
  ggtitle("Input Polylines to Rasterize\n(Seperated Bikelanes)") + 
  xlab("Longitude") + 
  ylab("Latitude") +
  theme_bw()


```

## Function


```{r}

sepbls_rast <- rasterize_lines(inputStudyArea = vancouver_boundary,
                                          inputLines = seperated_bl,
                                          cellSize = 100,
                                          buffWidth = 300,
                                          mask=TRUE)


```


## Output


```{r}
sepbls_rast_df <- as.data.frame(sepbls_rast, xy = TRUE)#covert raster file to dataframe to enable mapping in GGplot

ggplot() +
  geom_raster(data = sepbls_rast_df,aes(x=x,y=y,fill=layer)) + 
  scale_fill_viridis_c(name = "Metres of\nBikelanes\nwithin 300m") +
  ggtitle("City of Vancouver: Rasterized Separated Bikelanes") + 
  xlab("Longitude") + 
  ylab("Latitude") +
  coord_equal() + 
  theme_map() +
  theme(legend.position="bottom") +
  theme(legend.key.width=unit(2, "cm"))
```

```{r,include=FALSE}
ggsave(filename = "featured.jpeg",path="D:/GitHub/website-mbc/content/post/2020-10-21-rasterize-lines-in-r",units = "in",height = 5,width = 5,dpi = 250,device = "jpeg")
```
